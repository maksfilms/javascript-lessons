// Типы данных: 1) Примитивы, 2) Объекты (Object, Array, Function)
// Что отличает объект: структура, методы и свойства, ссылочный тип данных
// в переменной хранится ссылка в память на объект, а не данные. Поэтому:

const a = {}; // creating new Object() => #345 ячейка в памяти -> a
const b = {}; // creating new Object() => #523 ячейка в памяти-> b

console.log(a === b); // false потому-что ссылки разные
//---------------------------------------------------------

const user = {  //#789
    name: "Bob",
    age: 23
};
const superUser = user; // #789 В этот момент в памяти не создается новый объект, а это просто ссылка на объект выше.
/*superUser.name = "Alex"; // Затирается значение объекта user
console.log(user)*/ // user === 'Alex"

// Новый объект может быть создан только через литерал объекта {}, либо через функцию.
//---------------------------------------------------------------------------

// Создание нового объекта в памяти
const anotherUser = {}; //#253 // клон, копия объекта User, содержимое anotherUser и User одинаковое, но JS сравнивает ссылки поэтому объекты разные

anotherUser.name = user.name;
anotherUser.age = user.age;
console.log(anotherUser === user) //false

// ПОВЕРХОСТНАЯ КОПИЯ ОБЪЕКТА, это новый объект, у которого будет такое же содержимое (Spread operator), но вложенные объекты,
// которые были внутри user не будут новыми
const copyUser = {...user} // Spread operator, используется для создания копии объектов и массивов, ссылка в памяти одна

console.log(copyUser === user) // false
console.log(copyUser.name === user.name) //true

const names = ["Bob", "Alex", "Donald"];
const copyNames = [...names]; //копия массива names, ссылка в памяти одна и та же ячейка

//----------------------------------------------------------------------------------------------
// ГЛУБОКАЯ КОПИЯ ОБЪЕКТА, что бы все вложенные объекты были с новыми ссылками тоже

const user2 = {  //#789
    name: "Bob",
    age: 23,
    address: {street: 24},
    friends: ["Mark", "David"]
}

const deepCopyUser2 = {  // глубокая копия объекта user2
    ...user2,
    address: {...user2.address}, // создает новые ссылки на подобъекты address & friends с содержимым address
    // короткий способ копирования, как строка выше только через map
    //address: user2.address.map(a => ({...a}))
    friends: user2.friends.map(f => ({...f})) // user2 - из объекта берем массив friends, внутрь каждого массива f (friend) мы скопируем все.
}

/*
РАВИЛЬНО РАБОТАТЬ С ДАННЫМИ, ЕСЛИ МЫ ХОТИМ ЧТО-ТО ДОБАВИТЬ ИЛИ ЧТО-ТО ИЗМЕНИТЬ:
1) Делаем копию
2) Вносим изменения в копию
3) Используем копию с внесенными изменениями
Это позволит проинформировать библиотеку react что бы что-то обновили и перерисовать страницу

ЕСЛИ СИЛЬНО СЛОЖНАЯ СТРУКТКТУРА МОЖНО КОПИРОВАТЬ ТАКИМИ СПОСОБАМИ:

JSON.stringify --> объект будет превращен в строку
JSON.parse --> из строки делает новый литерал объекта
минусы, не все данные которые вложенные в объект которые корректно преобразуются с помощью этих методов
*/

// или библиотека lodash -> cloneDeep для копирования
//https://nuancesprog.ru/p/4443/
//https://www.npmjs.com/package/deepcopy


